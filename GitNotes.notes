In order to open the directory that you're currently in the terminal just type (start .) and it will open in file explorer sometimes it can be very useful.

To move/copy a file or folder to the parent directory you can use the command mv (fileName.ext ..) or cp (fileName.ext ..).

Instead of just writing ls you can even write ls folderName/path (A random folder in current directory or even a path for that matter) it will show it's contents too.h

You can use git add directoryName too incase you want to add an entire directory to the staging area.
One good practice to go by is making commits atomic basically make commits that focus on one feature of whatever but don't make commits that change a lot of files in lots of things and have not much of a relation with each other that will cause a lot of issues if you revert a commit.

For long commit messages you can change the default editor from vim to vscode easily using this command (git config --global core.editor "code --wait")
In these long commit messages you can even have paragraphs and bullet points and stuff.

git log incase of long commit messages is a troublesome thing to scroll through.
So, You can just use git log --oneline (What this does is it does two things one shortens the hash code and second is it only shows the first line of your commit messages.)

So, While making long commit messages make sure that the first line tells you okay this is exactly what you did and then add a blank line and then write the rest of longer message.(This is so when someone reads oneline explanation he/she should atleast be able to understand what happend due to this commit and if they want to go and read more about it they can just use git log rather than using git log --oneline)

Amending Commits :-
Suppose you just made a commit and then realized you forgot to include a file. Or, maybe you made a typo in the commit message that you want to correct.
Rather than making a brand new separate commit, you can "redo" the previous commit using the --amend option.
What git commit --amend does is it takes the new files in the staging area and adds it to the previous commit and also gives you an option to change the previous commit message through opening your default editor that you set up using git config.
So, If you let's just say you want to change the previous commit message you can just go ahead and use amend to change that without adding any files to the staging area cause if you add something to the staging area you will also be bundling that up with the previous commit.
Just remember git commit --amend can only make changes to the previous/most recent commit not to any of the previous commits before that.

Ignoring Files
We can tell Git which files and directories to ignore in a given repository, using a .gitignore file. This is useful for files you know you NEVER want to commit, including :-
• Secrets, API keys, credentials, etc.
• Operating System files (.DS—Store on Mac)
• Log files
• Dependencies & packages

To ignore files we can do it using .gitignore file.
Create a file called .gitignore in the root of a repository (or anywhere in the repository but it's a convention to do it in root directory). 
Inside the file, we can write patterns to tell Git which files 8 folders to ignore :-
• .DS_Store will ignore files named .DS_Store
• folderName/ will ignore an entire directory
• *.log will ignore any files with the .log extension
Also * means any pattern but ? means a single character so you can even have a git ignore line that says ?.log it will ignore all the files that are x.log (where x can be any character.)
gitignore.io is a good site that gives you a prebuilt gitignore file for any language you might be planning to work in so you don't have to go and add node_modules for every single JS project.

master/main branch is nothing special it has no extra unique powers or anything it's just your default branch that's it every single branch with any name will all have the same capabilities.

A branch is just a reference to some commit.(Think about it.)
Also one more thing each commit also has the hashcode of the previous commit too so it can go back to the previous commit.

git branch :- Shows all the branches you have in your project and also highlights the one you're currently on by putting a (*) in front of it.
git branch <branch-name> :-  This is used to make a new branch based upon the current HEAD (This line that you just read is exteremly important). This just creates the branch. It does not switch you to that branch (the HEAD stays the same).

git commit -a -m 'some message' is just doing git add . and then git commit -m 'some message'. So, it's basically doing it adds all the changes to the staging area and then commits with the message provided.

Instead of doing git branch newBranchName and then doing git switch newBranchName
You can create and switch to a new branch with just one step too that can be done using git switch -c newBranchName. (c stands for create)

Do keep in mind :-
git switch randomBranchName (This will give you an error if their is no branch by the name of randomBranchName so that -c flag is important).

git checkout <branch-name> can also be used for switching branches but it's a little bit older way of doing it.
git checkout -b <branch-name> is used to create and switch to the branch just like git switch -c <branch-name>

When you switch from one branch to other all the files and all the changes in all those files that we left it at will all be restored branches are not related to a single file.

