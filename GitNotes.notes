In order to open the directory that you're currently in the terminal just type (start .) and it will open in file explorer sometimes it can be very useful.

To move/copy a file or folder to the parent directory you can use the command mv (fileName.ext ..) or cp (fileName.ext ..).

Instead of just writing ls you can even write ls folderName/path (A random folder in current directory or even a path for that matter) it will show it's contents too.h

You can use git add directoryName too incase you want to add an entire directory to the staging area.
One good practice to go by is making commits atomic basically make commits that focus on one feature of whatever but don't make commits that change a lot of files in lots of things and have not much of a relation with each other that will cause a lot of issues if you revert a commit.

For long commit messages you can change the default editor from vim to vscode easily using this command (git config --global core.editor "code --wait")
In these long commit messages you can even have paragraphs and bullet points and stuff.

git log incase of long commit messages is a troublesome thing to scroll through.
So, You can just use git log --oneline (What this does is it does two things one shortens the hash code and second is it only shows the first line of your commit messages.)

So, While making long commit messages make sure that the first line tells you okay this is exactly what you did and then add a blank line and then write the rest of longer message.(This is so when someone reads oneline explanation he/she should atleast be able to understand what happend due to this commit and if they want to go and read more about it they can just use git log rather than using git log --oneline)

Amending Commits :-
Suppose you just made a commit and then realized you forgot to include a file. Or, maybe you made a typo in the commit message that you want to correct.
Rather than making a brand new separate commit, you can "redo" the previous commit using the --amend option.
What git commit --amend does is it takes the new files in the staging area and adds it to the previous commit and also gives you an option to change the previous commit message through opening your default editor that you set up using git config.
So, If you let's just say you want to change the previous commit message you can just go ahead and use amend to change that without adding any files to the staging area cause if you add something to the staging area you will also be bundling that up with the previous commit.
Just remember git commit --amend can only make changes to the previous/most recent commit not to any of the previous commits before that.

Ignoring Files
We can tell Git which files and directories to ignore in a given repository, using a .gitignore file. This is useful for files you know you NEVER want to commit, including :-
• Secrets, API keys, credentials, etc.
• Operating System files (.DS—Store on Mac)
• Log files
• Dependencies & packages

To ignore files we can do it using .gitignore file.
Create a file called .gitignore in the root of a repository (or anywhere in the repository but it's a convention to do it in root directory). 
Inside the file, we can write patterns to tell Git which files 8 folders to ignore :-
• .DS_Store will ignore files named .DS_Store
• folderName/ will ignore an entire directory
• *.log will ignore any files with the .log extension
Also * means any pattern but ? means a single character so you can even have a git ignore line that says ?.log it will ignore all the files that are x.log (where x can be any character.)
gitignore.io is a good site that gives you a prebuilt gitignore file for any language you might be planning to work in so you don't have to go and add node_modules for every single JS project.

master/main branch is nothing special it has no extra unique powers or anything it's just your default branch that's it every single branch with any name will all have the same capabilities.
Your branch name shouldn't have spaces.

A branch is just a reference to some commit.(Think about it.)
Also one more thing each commit also has the hashcode of the previous commit too so it can go back to the previous commit.

git branch :- Shows all the branches you have in your project and also highlights the one you're currently on by putting a (*) in front of it.
git branch <branch-name> :-  This is used to make a new branch based upon the current HEAD (This line that you just read is exteremly important). This just creates the branch. It does not switch you to that branch (the HEAD stays the same).

git commit -a -m 'some message' is just doing git add . and then git commit -m 'some message'. So, it's basically doing it adds all the changes to the staging area and then commits with the message provided.

Instead of doing git branch newBranchName and then doing git switch newBranchName
You can create and switch to a new branch with just one step too that can be done using git switch -c newBranchName. (c stands for create)

Do keep in mind :-
git switch randomBranchName (This will give you an error if their is no branch by the name of randomBranchName so that -c flag is important).

git checkout <branch-name> can also be used for switching branches but it's a little bit older way of doing it.
git checkout -b <branch-name> is used to create and switch to the branch just like git switch -c <branch-name>

When you switch from one branch to other all the files and all the changes in all those files that we left it at will all be restored branches are not related to a single file.

If you have a file that's part of two branches and if you try to write something in a file and without committing the changes you want to just go ahead and change the branch what that will do is it will give you a fair warning saying whatever you did in this file will be lost if you don't stash or commit these changes. 
We will learn about stashing later but for now we should commit if we want to preserve the data.
But let's say in a branch you created a completely new file and you switch to another branch without commiting that file that file will follow you to the new branch as well you will be able to switch to the other branch no problem but just keep in mind that file which didn't exist in the other branch will say okay i'm an untracked file.

Deleting a branch :-
In order to delete a branch we use the git branch -d <branch-name>
But first most important thing is you can't delete a branch if you're currently on it you must first move to a different branch if you want to delete it.
Second thing that you should also know is if you just use this command git branch -d <branch-name> it will only delete this branch if it has been merged with some other branch completely.
But if you're sure that you want to delete the branch without even merging you should use the -D flag.
So, git branch -D <branch-name> (even this command also you can use from after switching to other branch than the one you'd like to delete.) is your commad that you should use if you want to delete without merging.

Renaming a branch :-
In order to rename first you must switch to the branch that you want to rename. (It's opposite of deleting a branch)
Then use git branch -m UpdatedNameForThisBranch.

git branch -v (Shows all the branches but also shows the latest commit in each of those branches.)

Merging branches :-
If you want to merge a branch into some other branch you must do this :-
1 :- Switch to the branch in which the branch will be finally merged in like if you want to merge oldies branch into master first switch to master.
2 :- Then go ahead and write git merge oldies. 
If no commits have been done in the master branch since the oldies branch was made out of it but in oldies branch after it branched from master branch some commits have been done it is called a fast-forward merge. (In this all what happens is we just move the branch pointer of master to the latest commit in oldies that's it.)

Now coming to the case where the master branch had some more commits as you worked on your separate branch.
Now you might think that will always lead to an issue but that's not the case let's say in master branch you worked on randomFile.txt and in other branch you just worked on some other files all together and there is no conflict as in no line in common files is different in any of the files in that case we don't have to do much at all.
Just do git merge <branch-name> from the master branch if you want to merge into master branch.
If there are no conflicts you'll just be provided with a message window like you would in git commit and just write another message.
And a new commit will be created due to this merge and all the changes in both the branch's latest commits will be merged as well this is actually called a merge commit.

Sometimes you might have conflicts in multiple files as well while merging so you will have to resolve conflicts in all those files manually as well.
Also while merging two branches you don't have to just accept changes from one or the other or both you can even add extra stuff when coming to code you might even have to add extra comments or code that's needed in order for this merge to be successful and there is nothing wrong in doing that just because you're resolving conflicts that doesn't mean you have to be limited to only accepting code from one file or other or both.

Diff :-
git diff :- This command what it does is it gives shows you all the unstaged changes in the files that were once staged in previous commits. But if you stage these updated files it won't show you those changes in git diff. It's a bit weird let me explain further :-
            So, Basically it gives you the difference between your working directory and the staging area.
            Like let's say you have a file rainbow.txt and you committed with colors written red,orange.
            Now, If you add the color blue to it and without staging it if you type git diff it will show you oh. you have added blue cause this file was once staged when it was commited the last time.
            But if you stage this change and then type git diff then it won't show you any changes cause it's comparing the latest version of this file that came to it with the working directory.
            But if you add a new file that was never tracked by the previous commit and you have never added it to the staging area either during your last commit cause you made it after the commit.
            Now git diff won't show you any difference between staging area and this file even if you add this file to the staging area cause it's comparing it with the staging area file. (Without adding it to the staging even git diff HEAD won't show any difference cause the file would be untracked.)
            But if you add it to the staging area now and type git diff HEAD it will show you the changes cause it's comparing the commit where the HEAD is pointing and the staged and unstaged(That were once staged but staged now by that I mean they shouldn't be untracked files.)

git diff HEAD :- This command shows all the changes whether they be staged or unstaged between the commit where head in pointing no matter the branch and the current working directory.
